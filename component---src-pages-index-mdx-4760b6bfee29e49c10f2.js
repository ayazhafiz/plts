"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[4809],{42853:function(e,n,t){t.r(n),t.d(n,{default:function(){return u}});var l=t(27378);const a=l.createContext({});function r(e){const n=l.useContext(a);return l.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}var c=t(13826),i=t(97015),s=t(2778),o=t(72142);const m=function(e){let{children:n}=e;const t=Object.assign({title:"title",link:"link"},r());return l.createElement(l.Fragment,null,l.createElement(i.q,null,l.createElement(t.title,null,"plts"),l.createElement(t.link,{rel:"stylesheet",href:"https://unpkg.com/@primer/css/dist/primer.css"})),l.createElement(s.ZP,null,l.createElement(o.Z,{className:"markdown-body"},l.createElement(o.Z,{m:[4,4,10]},n))))};function p(e){const n=Object.assign({h1:"h1",p:"p",a:"a",ul:"ul",li:"li",h2:"h2",em:"em",code:"code"},r(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.h1,null,"plts ",l.createElement(c.Z)),"\n",l.createElement(n.p,null,"Implementations of type systems and programming languages I find interesting."),"\n",l.createElement(n.p,null,"Repository: ",l.createElement(n.a,{href:"https://github.com/ayazhafiz/plts"},"gh:ayazhafiz/plts"),"."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"#introductory"},"Introductory")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"#flow-typing"},"Flow Typing")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"#gradual-typing"},"Gradual Typing")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"#typed-assembly"},"Typed Assembly")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"#subtyping"},"Subtyping")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"#dependent-types"},"Dependent Types")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"#effects-and-coroutines"},"Effects and Coroutines")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"#roc"},"Roc")),"\n"),"\n",l.createElement(n.h2,null,"Introductory"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://ayazhafiz.com/articles/21/typescript-type-system-lambda-calculus"},"Emulating the Lambda Calculus in TypeScript's Type System"),": Evaluating the lambda calculus entirely using the TypeScript type system."),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/plts/blob/base/tapl"},"TAPL"),": Selected\nimplementations of languages formalized in ",l.createElement(n.em,null,"Types and Programming Languages"),"\n(Pierce 2002)."),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/tiger"},"Tiger"),": A compiler for the Tiger Language of Appel's 1998 ",l.createElement(n.a,{href:"https://www.cs.princeton.edu/~appel/modern/ml/index.html"},"Modern\nCompiler Implementation"),"."),"\n"),"\n"),"\n",l.createElement(n.h2,null,"Flow Typing"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://ayazhafiz.com/lang_narrow"},"lang_narrow"),": A language with unions,\nrecords, and flow typing. A checker, interpreter, and C code generator is\nimplemented."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/lang_narrow"},"Playground")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/articles/21/lang-narrow"},"Blog post")),"\n"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/ft"},"FT"),": The FT (flow typing) calculus from David\nPearce's 2012 paper ",l.createElement(n.a,{href:"https://ecs.wgtn.ac.nz/foswiki/pub/Main/TechnicalReportSeries/ECSTR12-20.pdf"},l.createElement(n.em,null,"Sound and Complete Flow Typing with Unions,\nIntersections, and Negations")),".\nLike ",l.createElement(n.code,null,"lang_narrow"),", but smaller and proven sound and complete. Includes a\nself-designed type inferer guaranteed to infer principal types."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/ft"},"Playground")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ecs.wgtn.ac.nz/foswiki/pub/Main/TechnicalReportSeries/ECSTR12-20.pdf"},"Pearce, 2012")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/articles/21/type-inference-for-flow-typing"},"Blog post"),": type inference for the calculus"),"\n"),"\n"),"\n"),"\n",l.createElement(n.h2,null,"Gradual Typing"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/gtlc"},"gtlc"),": A compiler for the gradually-typed lambda calculus,\nemploying the type consistency relation of ",l.createElement(n.a,{href:"http://www.schemeworkshop.org/2006/13-siek.pdf"},"Siek and Taha")," (2006).\nThe GTLC allows a developer to omit type annotations during development at\nthe expense of run-time type casts. While the ahead-of-time typechecker will\ncatch any non-sensical type errors, the runtime system will catch any cast\nerrors."),"\n",l.createElement(n.p,null,"The compiler is multi-phase, optimizing, includes an interpretive mode and a\ntype inferer, and provides code generators to C and TypeScript."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/gtlc"},"Playground")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"http://www.schemeworkshop.org/2006/13-siek.pdf"},"Siek and Taha, 2006")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.4703&rep=rep1&type=pdf"},"Type Inference for Gradual Typing (Siek and Vachharajani, 2008)")),"\n"),"\n"),"\n"),"\n",l.createElement(n.h2,null,"Typed Assembly"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/tal"},"TAL"),": A compiler from a System F-like language to the\nTyped Assembly Language of ",l.createElement(n.a,{href:"https://dash.harvard.edu/handle/1/2797451"},"Morrisett, et.al. 1998"),".\nAlso includes a compiler to x86 assembly using ",l.createElement(n.a,{href:"http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf"},"Linear Scan Register\nAllocation"),"\n(Poletto & Sarkar 1999).","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/tal"},"Playground")),"\n"),"\n"),"\n"),"\n",l.createElement(n.h2,null,"Subtyping"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/ho21"},"HO21"),": An implementation of the\nalgorithmic duotyping calculus invented by Huang and Oliveira in\n",l.createElement(n.a,{href:"https://dl.acm.org/doi/pdf/10.1145/3473594"},"Distributing Intersection and Union Types with Splits and Duality")," (2021).\nThe calculus includes union, intersection, and arrow types in the presence\nof non-trivial distributivity rules. The authors' duotyping algorithm is\nsomewhat novel in that it computes subtyping relationship entirely on\nsurface types of the language, without normalizing to a form like DNF.\nThis implementation includes a type-derivation tree generator."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/ho21"},"Playground")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://dl.acm.org/doi/pdf/10.1145/3473594"},"Huang and Oliveira, 2021")),"\n"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/plts/blob/base/simple_sub"},"simple_sub"),": A type system\nthat supports type inference in the presence of subtyping and polymorphism, as\ndescribed by Parreaux's ",l.createElement(n.em,null,l.createElement(n.a,{href:"https://lptk.github.io/files/%5Bv1.8%5D%20simple-essence-algebraic-subtyping.pdf"},"The Simple Essence of Algebraic Subtyping"))," (2020). Parreaux's\nwork distills Dolan's ",l.createElement(n.a,{href:"https://www.cs.tufts.edu/~nr/cs257/archive/stephen-dolan/thesis.pdf"},"2017 thesis"),"\non Algebraic Subtyping into a simpler core."),"\n"),"\n"),"\n",l.createElement(n.h2,null,"Dependent Types"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/plts/blob/base/deptypes"},"deptypes"),": A dependent\ntype theory as described in Chapter 2 of Pierce's ",l.createElement(n.em,null,"Advanced Topics in Types\nand Programming Languages"),"."),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/plts/pull/3"},"more deptypes"),": Additional,\nalternate implementations of the basic dependently-typed lambda calculus."),"\n"),"\n"),"\n",l.createElement(n.h2,null,"Effects and Coroutines"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/plts/blob/base/fx_cap"},"fx_cap"),": implements\neffect handlers via monadic translation of the capability-passing style."),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/plts/blob/base/co_lc"},"co_lc"),": a lambda calculus\nwith stackful coroutines and defunctionalized calls. Targets a bytecode stack\nmachine."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/co_lc"},"Playground")),"\n"),"\n"),"\n"),"\n",l.createElement(n.h2,null,"Roc"),"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/cor"},"cor")," is a minimalization of\n",l.createElement(n.a,{href:"https://roc-lang.org"},"Roc")," used for experimenting on the language and its\ncompiler."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/cor/tree/base/experiments/uls"},"cor/uls"),': A\nlanguage with "unspecialized lambda sets", a novel extension of the\nHindley-Milner type system that supports efficient resolution of ad-hoc\npolymorphic usages (a-la typeclasses) during unification.'),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://www.notion.so/rwx/Non-linear-monomorphization-0b26991a028949a285ca77a8ffcff3c5#1930c4eadf08465f9c7b96469f11f664"},"Documentation")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/cor/uls"},"Playground")),"\n"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/cor/tree/base/experiments/refine"},"cor/refine"),":\nAn experimental extension of Roc with refinement of types bound in branch\npatterns. Provides a flow-typing-like ergonomics for a unification-based HM\nsystem."),"\n",l.createElement(n.p,null,"Includes an compiler of pattern matching to decision trees, and various\nother optimizations."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/cor/refine"},"Playground")),"\n"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/cor/tree/base/experiments/easy_tags"},"cor/easy_tags"),":\nAn experimental extension of Roc with polymorphic variants' type variables\nelided in output positions."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/cor/easy_tags"},"Playground")),"\n"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://github.com/ayazhafiz/cor/tree/base/experiments/compose_fx"},"cor/compose_fx"),":\nA demonstration of composable effects as designed in Roc."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://ayazhafiz.com/plts/playground/cor/compose_fx"},"Playground")),"\n"),"\n"),"\n"))}var u=function(e){return void 0===e&&(e={}),l.createElement(m,e,l.createElement(p,e))}}}]);
//# sourceMappingURL=component---src-pages-index-mdx-4760b6bfee29e49c10f2.js.map