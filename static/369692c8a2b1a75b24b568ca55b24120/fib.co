# +solve -elab
# +ir -print
# +eval -print
let rec fib = \n ->
#       ^^^
  yield;
  if n < 2
  then n
  else (fib (n - 1)) + (fib (n - 2))
in

let rec exec = \state ->
#       ^^^^
  stat state.0
#      ^^^^^
  | `Pending ->
    let fib1 = resume state.0 in
#                     ^^^^^^^
    exec {fib1, 0, state.2 + 1}
  | `Done n -> {state.0, n, state.2}

in
let runFib = spawn (fib 20) in
let result = exec {runFib, 0, 0} in
#   ^^^^^^
{result.1, result.2}

> +solve -elab
> let rec fib = \n ->
> #       ^^^ int -[fib {}]-> int
>   yield;
>   if n < 2
>   then n
>   else (fib (n - 1)) + (fib (n - 2))
> in
> 
> let rec exec = \state ->
> #       ^^^^ {Fiber int; int; int}
> #       ^^^^   -[exec {}]-> {Fiber int; int; int}
>   stat state.0
> #      ^^^^^ {Fiber int; int; int}
>   | `Pending ->
>     let fib1 = resume state.0 in
> #                     ^^^^^^^ Fiber int
>     exec {fib1, 0, state.2 + 1}
>   | `Done n -> {state.0, n, state.2}
> 
> in
> let runFib = spawn (fib 20) in
> let result = exec {runFib, 0, 0} in
> #   ^^^^^^ {Fiber int; int; int}
> {result.1, result.2}
> 

> +ir -print
> exec: {
> % Stack relative to frame pointer:
> %   -15  #return.2
> %   -14  #return.1
> %   -13  #return.0.stkdirty
> %   -12  #return.0.stkidx
> %   -11  #return.0.return
> %   -10  #return.0.bit
> %    -9  state.2
> %    -8  state.1
> %    -7  state.0.stkdirty
> %    -6  state.0.stkidx
> %    -5  state.0.return
> %    -4  state.0.bit
> %    -3  @old_pc
> %    -2  @old_fp
> %    -1  @old_sp
> %     0  n1
> %     1  fib1.stkdirty
> %     2  fib1.stkidx
> %     3  fib1.return
> %     4  fib1.bit
> exec:
>   sp-add 5
> start2:
>   push fp[-7]
>   push fp[-6]
>   push fp[-5]
>   push fp[-4]
>   jmpz pending
> done:
>   store-into fp[0]
>   sp-sub 2
>   push fp[-9]
>   store-into fp[-15]
>   push fp[0]
>   store-into fp[-14]
>   push fp[-7]
>   push fp[-6]
>   push fp[-5]
>   push fp[-4]
>   store-into fp[-10]
>   store-into fp[-11]
>   store-into fp[-12]
>   store-into fp[-13]
>   ret
> pending:
>   sp-sub 3
>   push fp[-7]
>   push fp[-6]
>   push fp[-5]
>   push fp[-4]
>   resume 1
>   store-into fp[4]
>   store-into fp[3]
>   store-into fp[2]
>   store-into fp[1]
>   push 1
>   push fp[-9]
>   add
>   store-into fp[-9]
>   push 0
>   store-into fp[-8]
>   push fp[1]
>   push fp[2]
>   push fp[3]
>   push fp[4]
>   store-into fp[-4]
>   store-into fp[-5]
>   store-into fp[-6]
>   store-into fp[-7]
>   sp-restore-fp
>   jmp exec
> }
> 
> fib: {
> % Stack relative to frame pointer:
> %   -5  #return
> %   -4  n
> %   -3  @old_pc
> %   -2  @old_fp
> %   -1  @old_sp
> fib:
>   yield
>   push 2
>   push fp[-4]
>   <
>   jmpz else
> then:
>   push fp[-4]
>   store-into fp[-5]
>   ret
> else:
>   sp-add 1
>   push 2
>   push fp[-4]
>   sub
>   call fib
>   sp-sub 1
>   sp-add 1
>   push 1
>   push fp[-4]
>   sub
>   call fib
>   sp-sub 1
>   add
>   store-into fp[-5]
>   ret
> }
> 
> spawn_wrapper: {
> % Stack relative to frame pointer:
> %   -4  #return
> %   -3  @old_pc
> %   -2  @old_fp
> %   -1  @old_sp
> spawn_wrapper:
>   sp-add 1
>   push 20
>   call fib
>   sp-sub 1
>   store-into fp[-4]
>   ret
> }
> 
> @main: {
> % Stack relative to frame pointer:
> %   -5  #return.1
> %   -4  #return.0
> %   -3  @old_pc
> %   -2  @old_fp
> %   -1  @old_sp
> %    0  runFib.stkdirty
> %    1  runFib.stkidx
> %    2  runFib.return
> %    3  runFib.bit
> %    4  result.2
> %    5  result.1
> %    6  result.0.stkdirty
> %    7  result.0.stkidx
> %    8  result.0.return
> %    9  result.0.bit
> @main:
>   sp-add 10
> start:
>   spawn spawn_wrapper 0 1
>   store-into fp[3]
>   store-into fp[2]
>   store-into fp[1]
>   store-into fp[0]
>   sp-add 6
>   push 0
>   push 0
>   push fp[0]
>   push fp[1]
>   push fp[2]
>   push fp[3]
>   call exec
>   sp-sub 6
>   store-into fp[9]
>   store-into fp[8]
>   store-into fp[7]
>   store-into fp[6]
>   store-into fp[5]
>   store-into fp[4]
>   push fp[4]
>   store-into fp[-5]
>   push fp[5]
>   store-into fp[-4]
>   ret
> }

> +eval -print
> {6765, 21891}