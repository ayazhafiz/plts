{"version":3,"file":"component---src-pages-playground-ho-21-tsx-c35359ee786e112dd0c9.js","mappings":"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","sources":["webpack://www/./src/common/hover.ts","webpack://www/./src/pages/playground/ho21.tsx"],"sourcesContent":["import type * as monaco from 'monaco-editor';\n\nfunction doHover(\n    m: typeof monaco,\n    lang: string,\n    contentProvider: (item: string) => (monaco.IMarkdownString[] | null),\n    model: monaco.editor.IModel,\n    position: monaco.Position,\n    ): monaco.languages.ProviderResult<monaco.languages.Hover> {\n    const {lineNumber: line, column} = position;\n    const maxColumn = model.getLineMaxColumn(line);\n    const value = model.getValueInRange(\n        new m.Range(line, model.getLineMinColumn(line), line, maxColumn));\n    const tokens = m.editor.tokenize(model.getValue(), lang)[line - 1];\n\n    for (let i = 0; i < tokens.length; ++i) {\n        const start = tokens[i].offset + 1;\n        const end = tokens[i + 1] ? tokens[i + 1].offset + 1 : maxColumn;\n        if (column >= start && column < end) {\n            const word = value.substring(start - 1, end - 1);\n            const range = new m.Range(line, start, line, end);\n            const contents = contentProvider(word);\n            return contents && {range, contents};\n        }\n    }\n    return null;\n}\n\nexport const createHoverProvider =\n    (lang: string,\n     contentProvider: (item: string) => (monaco.IMarkdownString[] | null)) =>\n        (m: typeof monaco) =>\n            (model: monaco.editor.IModel, position: monaco.Position) =>\n                doHover(m, lang, contentProvider, model, position);\n","import type * as monaco from \"monaco-editor\";\nimport * as React from \"react\";\nimport Playground from \"../../components/playground\";\nimport { createHoverProvider } from \"../../common/hover\";\nimport type { Backend, LanguageRegistration } from \"../../common/types\";\nimport { promisify } from \"../../common/util\";\nimport ReactMarkdown from \"react-markdown\";\nimport * as ho21 from \"ho21\";\n\nconst examples = {\n  Queries: `\n⊥ ?? ⊤\nP∧Q ?? P∨Q\nP∧(Q∨R) ?? (P∧Q)∨(P∧R)∨(P∧Q∧R)\n(A1→A2)∧(B1→B2) ?? A1∧B1→A2∧B2\n(A1→B)∧(A2→B) ?? A1∨A2→B\n(A∨B)∧Int ?? A∨(Int∧B)\nInt ?? Double\n`.trim(),\n};\n\nconst backends: {\n  [K in \"Check\"]: [Backend];\n} = {\n  Check: [\n    {\n      title: \"Judgements\",\n      do: promisify(ho21.judge),\n      options: [\n        [\"Print Derivations\", true],\n        [\"Prettify Symbols\", true],\n      ],\n      editorLanguage: \"ho21\",\n    },\n  ],\n};\n\nconst ho21Syntax: monaco.languages.IMonarchLanguage = {\n  defaultToken: \"invalid\",\n\n  constant_types: [\"!\", \"*\", \"\\u22A4\", \"\\u22A5\"],\n  queries: [\"??\"],\n  judgements: [\"<:\", \":>\", \"~=\", \"#\", \"\\u227A\", \"\\u227B\", \"\\u2245\"],\n  operators: [\"&\", \"|\", \"->\", \"\\u2227\", \"\\u2228\", \"\\u2192\"],\n  symbols: /[=><!~?:&|+\\-*\\/\\^%#\\u22A4\\u22A5\\u2227\\u2228\\u2192\\u227A\\u227B\\u2245]+/,\n\n  tokenizer: {\n    root: [\n      [/(Syntax error.*)/, \"error\"],\n      [/(Parse error.*)/, \"error\"],\n      [/[A-Z][a-zA-Z0-9_'\\w$]*/, \"type.identifier\"],\n      { include: \"@whitespace\" },\n      [/[()]/, \"@brackets\"],\n      [\n        /@symbols/,\n        {\n          cases: {\n            \"@constant_types\": \"keyword\",\n            \"@queries\": \"annotation\",\n            \"@judgements\": \"keyword\",\n            \"@operators\": \"operator\",\n          },\n        },\n      ],\n    ],\n    whitespace: [\n      [/(\\uFF5C.*$)/, \"annotation\"],\n      [/[ \\t\\r\\n]+/, \"white\"],\n      [/(--.*$)/, \"comment\"],\n      [/(\\\\.*$)/, \"annotation\"],\n    ],\n  },\n};\n\nconst languageContent = [\n  { aliases: [\"!\", \"⊥\"], kind: \"⊥\", text: \"The bottom type\", binary: false },\n  { aliases: [\"*\", \"⊤\"], kind: \"⊤\", text: \"The top type\", binary: false },\n  {\n    aliases: [\"&\", \"∧\"],\n    kind: \"Operator\",\n    text: \"An intersection type\",\n    binary: true,\n  },\n  { aliases: [\"|\", \"∨\"], kind: \"Operator\", text: \"A union type\", binary: true },\n  {\n    aliases: [\"->\", \"→\"],\n    kind: \"Operator\",\n    text: \"An arrow (function) type\",\n    binary: true,\n  },\n  {\n    aliases: [\"??\"],\n    kind: \"Query\",\n    text: \"A judgement query for the relationship between A and B, which will be answered in the output editor.\",\n    binary: true,\n  },\n  {\n    aliases: [\"<:\", \"≺\"],\n    kind: \"Judgement\",\n    text: \"`S <: T` means `S` is a subtype of `T`\",\n    outputOnly: true,\n  },\n  {\n    aliases: [\":>\", \"≻\"],\n    kind: \"Judgement\",\n    text: \"`T :> S` means `T` is a supertype of `S`\",\n    outputOnly: true,\n  },\n  {\n    aliases: [\"~=\", \"≅\"],\n    kind: \"Judgement\",\n    text: \"`T ~= S` means `T` is isomorphic to `S`\",\n    outputOnly: true,\n  },\n  {\n    aliases: [\"#\"],\n    kind: \"Judgement\",\n    text: \"`T # U` means `T` and `U` are incomparable\",\n    outputOnly: true,\n  },\n];\n\nfunction getLanguageGrammarInfo() {\n  const inputItems = languageContent.filter((lc) => !lc.outputOnly);\n  const itemDocs = inputItems.map(({ aliases, text, binary }) => {\n    const examples = aliases\n      .map((alias) => {\n        const example = binary ? `A${alias}B` : alias;\n        return `\\`${example}\\``;\n      })\n      .join(\"/\");\n    return `- ${examples}: ${text}`;\n  });\n  itemDocs.push(\n    `- Other types: Identifiers beginning with an uppercase letter are treated as primitive types.j`\n  );\n  const listDocs = itemDocs.join(\"\\n\");\n  return `${listDocs}\\n[Full Parser Specification](https://github.com/ayazhafiz/plts/blob/base/huang_oliveira_21/parser.mly)`;\n}\n\nconst grammar = <ReactMarkdown children={getLanguageGrammarInfo()} />;\n\nfunction ho21GetHoverContent(word: string) {\n  for (const { aliases, text } of languageContent) {\n    for (const alias of aliases) {\n      if (word === alias) {\n        const content = [\n          // {value: `**${kind}**`},\n          { value: text },\n        ];\n        if (aliases.length > 1) {\n          content.push({ value: `*Aliases*: ${aliases.join(\", \")}` });\n        }\n        return content;\n      }\n    }\n  }\n  if (word[0] === word[0].toUpperCase() && word[0] !== word[0].toLowerCase()) {\n    return [{ value: \"**Primitive**\" }, { value: `Type primitive \\`${word}\\`` }];\n  }\n  return null;\n}\n\nfunction ho21FormatQueries(\n  model: monaco.editor.IModel\n): monaco.languages.ProviderResult<monaco.languages.TextEdit[]> {\n  const text = ho21.formatQueries(model.getValue(), true);\n  return [\n    {\n      text,\n      range: model.getFullModelRange(),\n    },\n  ];\n}\n\nfunction ho21OnTypeFormatQueries(\n  model: monaco.editor.IModel\n): monaco.languages.ProviderResult<monaco.languages.TextEdit[]> {\n  const text = ho21.formatQueries(model.getValue(), true);\n  return [\n    {\n      text,\n      range: model.getFullModelRange(),\n    },\n  ];\n}\n\nfunction getHo21AutoFormatCharacters() {\n  const all = [];\n  all.push(...\"abcdefghijklmnopqrstuvwxyz\".split(\"\"));\n  all.push(...\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\"));\n  all.push(...\"0123456789\".split(\"\"));\n  all.push(...\"()_'\".split(\"\"));\n  all.push(...ho21Syntax[\"constant_types\"].join(\"\").split(\"\"));\n  all.push(...ho21Syntax[\"queries\"].join(\"\").split(\"\"));\n  all.push(...ho21Syntax[\"judgements\"].join(\"\").split(\"\"));\n  all.push(...ho21Syntax[\"operators\"].join(\"\").split(\"\"));\n  return all;\n}\n\nconst languages: Record<string, LanguageRegistration> = {\n  ho21: {\n    syntax: ho21Syntax,\n    hover: createHoverProvider(\"ho21\", ho21GetHoverContent),\n    format: ho21FormatQueries,\n    autoFormat: {\n      format: ho21OnTypeFormatQueries,\n      triggerCharacters: getHo21AutoFormatCharacters(),\n    },\n  },\n};\n\nconst FtPlayground = () => (\n  <Playground\n    title=\"Huang-Oliveira (2021) Playground\"\n    language=\"ho21\"\n    source=\"https://github.com/ayazhafiz/plts/tree/base/ho21\"\n    grammar={grammar}\n    languageRegistrations={languages}\n    backends={backends}\n    defaultBackend=\"Check\"\n    examples={examples}\n    defaultExample=\"Queries\"\n  />\n);\nexport default FtPlayground;\n"],"names":["examples","Queries","backends","Check","title","do","promisify","ho21","judge","options","editorLanguage","ho21Syntax","defaultToken","constant_types","queries","judgements","operators","symbols","tokenizer","root","include","cases","whitespace","languageContent","aliases","kind","text","binary","outputOnly","itemDocs","grammar","children","lc","all","lang","languages","syntax","hover","word","content","value","line","position","column","maxColumn","model","m","tokens","i","start","end","range","contents","contentProvider","doHover","format","formatQueries","autoFormat","triggerCharacters","split","language","source","languageRegistrations","defaultBackend","defaultExample"],"sourceRoot":""}