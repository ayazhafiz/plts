{"version":3,"file":"component---src-pages-playground-ho-21-tsx-76a6c94fdb7e02be4960.js","mappings":"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","sources":["webpack://www/./src/common/hover.ts","webpack://www/./src/pages/playground/ho21.tsx"],"sourcesContent":["import type * as monaco from 'monaco-editor';\n\nfunction doHover(\n    m: typeof monaco,\n    lang: string,\n    contentProvider: (item: string) => (monaco.IMarkdownString[] | null),\n    model: monaco.editor.IModel,\n    position: monaco.Position,\n    ): monaco.languages.ProviderResult<monaco.languages.Hover> {\n    const {lineNumber: line, column} = position;\n    const maxColumn = model.getLineMaxColumn(line);\n    const value = model.getValueInRange(\n        new m.Range(line, model.getLineMinColumn(line), line, maxColumn));\n    const tokens = m.editor.tokenize(model.getValue(), lang)[line - 1];\n\n    for (let i = 0; i < tokens.length; ++i) {\n        const start = tokens[i].offset + 1;\n        const end = tokens[i + 1] ? tokens[i + 1].offset + 1 : maxColumn;\n        if (column >= start && column < end) {\n            const word = value.substring(start - 1, end - 1);\n            const range = new m.Range(line, start, line, end);\n            const contents = contentProvider(word);\n            return contents && {range, contents};\n        }\n    }\n    return null;\n}\n\nexport const createHoverProvider =\n    (lang: string,\n     contentProvider: (item: string) => (monaco.IMarkdownString[] | null)) =>\n        (m: typeof monaco) =>\n            (model: monaco.editor.IModel, position: monaco.Position) =>\n                doHover(m, lang, contentProvider, model, position);\n","import type * as monaco from \"monaco-editor\";\nimport * as React from \"react\";\nimport Playground from \"../../components/playground\";\nimport { createHoverProvider } from \"../../common/hover\";\nimport type { Backend, LanguageRegistration } from \"../../common/types\";\nimport { promisify } from \"../../common/util\";\nimport ReactMarkdown from \"react-markdown\";\nimport * as ho21 from \"ho21\";\n\nconst examples = {\n  Queries: `\n⊥ ?? ⊤\nP∧Q ?? P∨Q\nP∧(Q∨R) ?? (P∧Q)∨(P∧R)∨(P∧Q∧R)\n(A1→A2)∧(B1→B2) ?? A1∧B1→A2∧B2\n(A1→B)∧(A2→B) ?? A1∨A2→B\n(A∨B)∧Int ?? A∨(Int∧B)\nInt ?? Double\n`.trim(),\n};\n\nconst backends: {\n  [K in \"Check\"]: [Backend];\n} = {\n  Check: [\n    {\n      title: \"Judgements\",\n      do: promisify(ho21.judge),\n      options: [\n        [\"Print Derivations\", true],\n        [\"Prettify Symbols\", true],\n      ],\n      editorLanguage: \"ho21\",\n    },\n  ],\n};\n\nconst ho21Syntax: monaco.languages.IMonarchLanguage = {\n  defaultToken: \"invalid\",\n\n  constant_types: [\"!\", \"*\", \"\\u22A4\", \"\\u22A5\"],\n  queries: [\"??\"],\n  judgements: [\"<:\", \":>\", \"~=\", \"#\", \"\\u227A\", \"\\u227B\", \"\\u2245\"],\n  operators: [\"&\", \"|\", \"->\", \"\\u2227\", \"\\u2228\", \"\\u2192\"],\n  symbols: /[=><!~?:&|+\\-*\\/\\^%#\\u22A4\\u22A5\\u2227\\u2228\\u2192\\u227A\\u227B\\u2245]+/,\n\n  tokenizer: {\n    root: [\n      [/(Syntax error.*)/, \"error\"],\n      [/(Parse error.*)/, \"error\"],\n      [/[A-Z][a-zA-Z0-9_'\\w$]*/, \"type.identifier\"],\n      { include: \"@whitespace\" },\n      [/[()]/, \"@brackets\"],\n      [\n        /@symbols/,\n        {\n          cases: {\n            \"@constant_types\": \"keyword\",\n            \"@queries\": \"annotation\",\n            \"@judgements\": \"keyword\",\n            \"@operators\": \"operator\",\n          },\n        },\n      ],\n    ],\n    whitespace: [\n      [/(\\uFF5C.*$)/, \"annotation\"],\n      [/[ \\t\\r\\n]+/, \"white\"],\n      [/(--.*$)/, \"comment\"],\n      [/(\\\\.*$)/, \"annotation\"],\n    ],\n  },\n};\n\nconst languageContent = [\n  { aliases: [\"!\", \"⊥\"], kind: \"⊥\", text: \"The bottom type\", binary: false },\n  { aliases: [\"*\", \"⊤\"], kind: \"⊤\", text: \"The top type\", binary: false },\n  {\n    aliases: [\"&\", \"∧\"],\n    kind: \"Operator\",\n    text: \"An intersection type\",\n    binary: true,\n  },\n  { aliases: [\"|\", \"∨\"], kind: \"Operator\", text: \"A union type\", binary: true },\n  {\n    aliases: [\"->\", \"→\"],\n    kind: \"Operator\",\n    text: \"An arrow (function) type\",\n    binary: true,\n  },\n  {\n    aliases: [\"??\"],\n    kind: \"Query\",\n    text: \"A judgement query for the relationship between A and B, which will be answered in the output editor.\",\n    binary: true,\n  },\n  {\n    aliases: [\"<:\", \"≺\"],\n    kind: \"Judgement\",\n    text: \"`S <: T` means `S` is a subtype of `T`\",\n    outputOnly: true,\n  },\n  {\n    aliases: [\":>\", \"≻\"],\n    kind: \"Judgement\",\n    text: \"`T :> S` means `T` is a supertype of `S`\",\n    outputOnly: true,\n  },\n  {\n    aliases: [\"~=\", \"≅\"],\n    kind: \"Judgement\",\n    text: \"`T ~= S` means `T` is isomorphic to `S`\",\n    outputOnly: true,\n  },\n  {\n    aliases: [\"#\"],\n    kind: \"Judgement\",\n    text: \"`T # U` means `T` and `U` are incomparable\",\n    outputOnly: true,\n  },\n];\n\nfunction getLanguageGrammarInfo() {\n  const inputItems = languageContent.filter((lc) => !lc.outputOnly);\n  const itemDocs = inputItems.map(({ aliases, text, binary }) => {\n    const examples = aliases\n      .map((alias) => {\n        const example = binary ? `A${alias}B` : alias;\n        return `\\`${example}\\``;\n      })\n      .join(\"/\");\n    return `- ${examples}: ${text}`;\n  });\n  itemDocs.push(\n    `- Other types: Identifiers beginning with an uppercase letter are treated as primitive types.j`\n  );\n  const listDocs = itemDocs.join(\"\\n\");\n  return `${listDocs}\\n[Full Parser Specification](https://github.com/ayazhafiz/plts/blob/base/huang_oliveira_21/parser.mly)`;\n}\n\nconst grammar = <ReactMarkdown children={getLanguageGrammarInfo()} />;\n\nfunction ho21GetHoverContent(word: string) {\n  for (const { aliases, text } of languageContent) {\n    for (const alias of aliases) {\n      if (word === alias) {\n        const content = [\n          // {value: `**${kind}**`},\n          { value: text },\n        ];\n        if (aliases.length > 1) {\n          content.push({ value: `*Aliases*: ${aliases.join(\", \")}` });\n        }\n        return content;\n      }\n    }\n  }\n  if (word[0] === word[0].toUpperCase() && word[0] !== word[0].toLowerCase()) {\n    return [{ value: \"**Primitive**\" }, { value: `Type primitive \\`${word}\\`` }];\n  }\n  return null;\n}\n\nfunction ho21FormatQueries(\n  model: monaco.editor.IModel\n): monaco.languages.ProviderResult<monaco.languages.TextEdit[]> {\n  const text = ho21.formatQueries(model.getValue(), true);\n  return [\n    {\n      text,\n      range: model.getFullModelRange(),\n    },\n  ];\n}\n\nfunction ho21OnTypeFormatQueries(\n  model: monaco.editor.IModel\n): monaco.languages.ProviderResult<monaco.languages.TextEdit[]> {\n  const text = ho21.formatQueries(model.getValue(), true);\n  return [\n    {\n      text,\n      range: model.getFullModelRange(),\n    },\n  ];\n}\n\nfunction getHo21AutoFormatCharacters() {\n  const all = [];\n  all.push(...\"abcdefghijklmnopqrstuvwxyz\".split(\"\"));\n  all.push(...\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\"));\n  all.push(...\"0123456789\".split(\"\"));\n  all.push(...\"()_'\".split(\"\"));\n  all.push(...ho21Syntax[\"constant_types\"].join(\"\").split(\"\"));\n  all.push(...ho21Syntax[\"queries\"].join(\"\").split(\"\"));\n  all.push(...ho21Syntax[\"judgements\"].join(\"\").split(\"\"));\n  all.push(...ho21Syntax[\"operators\"].join(\"\").split(\"\"));\n  return all;\n}\n\nconst languages: Record<string, LanguageRegistration> = {\n  ho21: {\n    syntax: ho21Syntax,\n    hover: createHoverProvider(\"ho21\", ho21GetHoverContent),\n    format: ho21FormatQueries,\n    autoFormat: {\n      format: ho21OnTypeFormatQueries,\n      triggerCharacters: getHo21AutoFormatCharacters(),\n    },\n  },\n};\n\nconst FtPlayground = () => (\n  <Playground\n    language=\"ho21\"\n    source=\"https://github.com/ayazhafiz/plts/tree/base/ho21\"\n    grammar={grammar}\n    languageRegistrations={languages}\n    backends={backends}\n    defaultBackend=\"Check\"\n    examples={examples}\n    defaultExample=\"Queries\"\n  />\n);\nexport default FtPlayground;\n"],"names":["createHoverProvider","lang","contentProvider","m","model","position","line","lineNumber","column","maxColumn","getLineMaxColumn","value","getValueInRange","Range","getLineMinColumn","tokens","editor","tokenize","getValue","i","length","start","offset","end","word","substring","range","contents","doHover","examples","Queries","trim","backends","Check","title","do","promisify","ho21","options","editorLanguage","ho21Syntax","defaultToken","constant_types","queries","judgements","operators","symbols","tokenizer","root","include","cases","whitespace","languageContent","aliases","kind","text","binary","outputOnly","itemDocs","grammar","children","filter","lc","map","alias","join","push","all","languages","syntax","hover","content","toUpperCase","toLowerCase","format","getFullModelRange","autoFormat","triggerCharacters","split","language","source","languageRegistrations","defaultBackend","defaultExample"],"sourceRoot":""}