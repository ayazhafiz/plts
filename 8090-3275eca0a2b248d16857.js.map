{"version":3,"file":"8090-3275eca0a2b248d16857.js","mappings":"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","sources":["webpack://www/../node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport var conf = {\n  comments: {\n    lineComment: '#'\n  },\n  brackets: [['{', '}'], ['[', ']'], ['(', ')']],\n  surroundingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }],\n  autoClosingPairs: [{\n    open: \"'\",\n    close: \"'\",\n    notIn: ['string', 'comment']\n  }, {\n    open: '\"',\n    close: '\"',\n    notIn: ['comment']\n  }, {\n    open: '\"\"\"',\n    close: '\"\"\"'\n  }, {\n    open: '`',\n    close: '`',\n    notIn: ['string', 'comment']\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '<<',\n    close: '>>'\n  }],\n  indentationRules: {\n    increaseIndentPattern: /^\\s*(after|else|catch|rescue|fn|[^#]*(do|<\\-|\\->|\\{|\\[|\\=))\\s*$/,\n    decreaseIndentPattern: /^\\s*((\\}|\\])\\s*$|(after|else|catch|rescue|end)\\b)/\n  }\n};\n/**\r\n * A Monarch lexer for the Elixir language.\r\n *\r\n * References:\r\n *\r\n * * Monarch documentation - https://microsoft.github.io/monaco-editor/monarch.html\r\n * * Elixir lexer - https://github.com/elixir-makeup/makeup_elixir/blob/master/lib/makeup/lexers/elixir_lexer.ex\r\n * * TextMate lexer (elixir-tmbundle) - https://github.com/elixir-editors/elixir-tmbundle/blob/master/Syntaxes/Elixir.tmLanguage\r\n * * TextMate lexer (vscode-elixir-ls) - https://github.com/elixir-lsp/vscode-elixir-ls/blob/master/syntaxes/elixir.json\r\n */\n\nexport var language = {\n  defaultToken: 'source',\n  tokenPostfix: '.elixir',\n  brackets: [{\n    open: '[',\n    close: ']',\n    token: 'delimiter.square'\n  }, {\n    open: '(',\n    close: ')',\n    token: 'delimiter.parenthesis'\n  }, {\n    open: '{',\n    close: '}',\n    token: 'delimiter.curly'\n  }, {\n    open: '<<',\n    close: '>>',\n    token: 'delimiter.angle.special'\n  }],\n  // Below are lists/regexps to which we reference later.\n  declarationKeywords: ['def', 'defp', 'defn', 'defnp', 'defguard', 'defguardp', 'defmacro', 'defmacrop', 'defdelegate', 'defcallback', 'defmacrocallback', 'defmodule', 'defprotocol', 'defexception', 'defimpl', 'defstruct'],\n  operatorKeywords: ['and', 'in', 'not', 'or', 'when'],\n  namespaceKeywords: ['alias', 'import', 'require', 'use'],\n  otherKeywords: ['after', 'case', 'catch', 'cond', 'do', 'else', 'end', 'fn', 'for', 'if', 'quote', 'raise', 'receive', 'rescue', 'super', 'throw', 'try', 'unless', 'unquote_splicing', 'unquote', 'with'],\n  constants: ['true', 'false', 'nil'],\n  nameBuiltin: ['__MODULE__', '__DIR__', '__ENV__', '__CALLER__', '__STACKTRACE__'],\n  // Matches any of the operator names:\n  // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\\\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !\n  operator: /-[->]?|!={0,2}|\\*|\\/|\\\\\\\\|&{1,3}|\\.\\.?|\\^(?:\\^\\^)?|\\+\\+?|<(?:-|<<|=|>|\\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\\|~>|\\|>|\\|{1,3}|~>>?|~~~|::/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#variables\n  variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#atoms\n  atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,\n  specialAtomName: /\\.\\.\\.|<<>>|%\\{\\}|%|\\{\\}/,\n  aliasPart: /[A-Z][a-zA-Z0-9_]*/,\n  moduleName: /@aliasPart(?:\\.@aliasPart)*/,\n  // Sigil pairs are: \"\"\" \"\"\", ''' ''', \" \", ' ', / /, | |, < >, { }, [ ], ( )\n  sigilSymmetricDelimiter: /\"\"\"|'''|\"|'|\\/|\\|/,\n  sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\\{|\\[|\\(/,\n  sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\\}|\\]|\\)/,\n  decimal: /\\d(?:_?\\d)*/,\n  hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,\n  octal: /[0-7](_?[0-7])*/,\n  binary: /[01](_?[01])*/,\n  // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters\n  escape: /\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\./,\n  // The keys below correspond to tokenizer states.\n  // We start from the root state and match against its rules\n  // until we explicitly transition into another state.\n  // The `include` simply brings in all operations from the given state\n  // and is useful for improving readability.\n  tokenizer: {\n    root: [{\n      include: '@whitespace'\n    }, {\n      include: '@comments'\n    }, // Keywords start as either an identifier or a string,\n    // but end with a : so it's important to match this first.\n    {\n      include: '@keywordsShorthand'\n    }, {\n      include: '@numbers'\n    }, {\n      include: '@identifiers'\n    }, {\n      include: '@strings'\n    }, {\n      include: '@atoms'\n    }, {\n      include: '@sigils'\n    }, {\n      include: '@attributes'\n    }, {\n      include: '@symbols'\n    }],\n    // Whitespace\n    whitespace: [[/\\s+/, 'white']],\n    // Comments\n    comments: [[/(#)(.*)/, ['comment.punctuation', 'comment']]],\n    // Keyword list shorthand\n    keywordsShorthand: [[/(@atomName)(:)/, ['constant', 'constant.punctuation']], // Use positive look-ahead to ensure the string is followed by :\n    // and should be considered a keyword.\n    [/\"(?=([^\"]|#\\{.*?\\}|\\\\\")*\":)/, {\n      token: 'constant.delimiter',\n      next: '@doubleQuotedStringKeyword'\n    }], [/'(?=([^']|#\\{.*?\\}|\\\\')*':)/, {\n      token: 'constant.delimiter',\n      next: '@singleQuotedStringKeyword'\n    }]],\n    doubleQuotedStringKeyword: [[/\":/, {\n      token: 'constant.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringConstantContentInterpol'\n    }],\n    singleQuotedStringKeyword: [[/':/, {\n      token: 'constant.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringConstantContentInterpol'\n    }],\n    // Numbers\n    numbers: [[/0b@binary/, 'number.binary'], [/0o@octal/, 'number.octal'], [/0x@hex/, 'number.hex'], [/@decimal\\.@decimal([eE]-?@decimal)?/, 'number.float'], [/@decimal/, 'number']],\n    // Identifiers\n    identifiers: [// Tokenize identifier name in function-like definitions.\n    // Note: given `def a + b, do: nil`, `a` is not a function name,\n    // so we use negative look-ahead to ensure there's no operator.\n    [/\\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\\s+)(@variableName)(?!\\s+@operator)/, ['keyword.declaration', 'white', {\n      cases: {\n        unquote: 'keyword',\n        '@default': 'function'\n      }\n    }]], // Tokenize function calls\n    [// In-scope call - an identifier followed by ( or .(\n    /(@variableName)(?=\\s*\\.?\\s*\\()/, {\n      cases: {\n        // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`\n        '@declarationKeywords': 'keyword.declaration',\n        '@namespaceKeywords': 'keyword',\n        '@otherKeywords': 'keyword',\n        '@default': 'function.call'\n      }\n    }], [// Referencing function in a module\n    /(@moduleName)(\\s*)(\\.)(\\s*)(@variableName)/, ['type.identifier', 'white', 'operator', 'white', 'function.call']], [// Referencing function in an Erlang module\n    /(:)(@atomName)(\\s*)(\\.)(\\s*)(@variableName)/, ['constant.punctuation', 'constant', 'white', 'operator', 'white', 'function.call']], [// Piping into a function (tokenized separately as it may not have parentheses)\n    /(\\|>)(\\s*)(@variableName)/, ['operator', 'white', {\n      cases: {\n        '@otherKeywords': 'keyword',\n        '@default': 'function.call'\n      }\n    }]], [// Function reference passed to another function\n    /(&)(\\s*)(@variableName)/, ['operator', 'white', 'function.call']], // Language keywords, builtins, constants and variables\n    [/@variableName/, {\n      cases: {\n        '@declarationKeywords': 'keyword.declaration',\n        '@operatorKeywords': 'keyword.operator',\n        '@namespaceKeywords': 'keyword',\n        '@otherKeywords': 'keyword',\n        '@constants': 'constant.language',\n        '@nameBuiltin': 'variable.language',\n        '_.*': 'comment.unused',\n        '@default': 'identifier'\n      }\n    }], // Module names\n    [/@moduleName/, 'type.identifier']],\n    // Strings\n    strings: [[/\"\"\"/, {\n      token: 'string.delimiter',\n      next: '@doubleQuotedHeredoc'\n    }], [/'''/, {\n      token: 'string.delimiter',\n      next: '@singleQuotedHeredoc'\n    }], [/\"/, {\n      token: 'string.delimiter',\n      next: '@doubleQuotedString'\n    }], [/'/, {\n      token: 'string.delimiter',\n      next: '@singleQuotedString'\n    }]],\n    doubleQuotedHeredoc: [[/\"\"\"/, {\n      token: 'string.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    singleQuotedHeredoc: [[/'''/, {\n      token: 'string.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    doubleQuotedString: [[/\"/, {\n      token: 'string.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    singleQuotedString: [[/'/, {\n      token: 'string.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    // Atoms\n    atoms: [[/(:)(@atomName)/, ['constant.punctuation', 'constant']], [/:\"/, {\n      token: 'constant.delimiter',\n      next: '@doubleQuotedStringAtom'\n    }], [/:'/, {\n      token: 'constant.delimiter',\n      next: '@singleQuotedStringAtom'\n    }]],\n    doubleQuotedStringAtom: [[/\"/, {\n      token: 'constant.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringConstantContentInterpol'\n    }],\n    singleQuotedStringAtom: [[/'/, {\n      token: 'constant.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringConstantContentInterpol'\n    }],\n    // Sigils\n    // See https://elixir-lang.org/getting-started/sigils.html\n    // Sigils allow for typing values using their textual representation.\n    // All sigils start with ~ followed by a letter indicating sigil type\n    // and then a delimiter pair enclosing the textual representation.\n    // Optional modifiers are allowed after the closing delimiter.\n    // For instance a regular expressions can be written as:\n    // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g\n    //\n    // In general lowercase sigils allow for interpolation\n    // and escaped characters, whereas uppercase sigils don't\n    //\n    // During tokenization we want to distinguish some\n    // specific sigil types, namely string and regexp,\n    // so that they cen be themed separately.\n    //\n    // To reasonably handle all those combinations we leverage\n    // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}\n    // then \"sigilStart.interpol.s\" state will match and also all\n    // the individual dot-separated parameters can be accessed.\n    sigils: [[/~[a-z]@sigilStartDelimiter/, {\n      token: '@rematch',\n      next: '@sigil.interpol'\n    }], [/~[A-Z]@sigilStartDelimiter/, {\n      token: '@rematch',\n      next: '@sigil.noInterpol'\n    }]],\n    sigil: [[/~([a-zA-Z])\\{/, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.{.}'\n    }], [/~([a-zA-Z])\\[/, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.[.]'\n    }], [/~([a-zA-Z])\\(/, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.(.)'\n    }], [/~([a-zA-Z])\\</, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.<.>'\n    }], [/~([a-zA-Z])(@sigilSymmetricDelimiter)/, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.$2.$2'\n    }]],\n    // The definitions below expect states to be of the form:\n    //\n    // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    //\n    // The sigilStart state is used only to properly classify the token (as string/regex/sigil)\n    // and immediately switches to the sigilContinue sate, which handles the actual content\n    // and waits for the corresponding end delimiter.\n    'sigilStart.interpol.s': [[/~s@sigilStartDelimiter/, {\n      token: 'string.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.interpol.s': [[/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'string.delimiter',\n          next: '@pop'\n        },\n        '@default': 'string'\n      }\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    'sigilStart.noInterpol.S': [[/~S@sigilStartDelimiter/, {\n      token: 'string.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.noInterpol.S': [// Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'string'], [/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'string.delimiter',\n          next: '@pop'\n        },\n        '@default': 'string'\n      }\n    }], {\n      include: '@stringContent'\n    }],\n    'sigilStart.interpol.r': [[/~r@sigilStartDelimiter/, {\n      token: 'regexp.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.interpol.r': [[/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'regexp.delimiter',\n          next: '@pop'\n        },\n        '@default': 'regexp'\n      }\n    }], {\n      include: '@regexpContentInterpol'\n    }],\n    'sigilStart.noInterpol.R': [[/~R@sigilStartDelimiter/, {\n      token: 'regexp.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.noInterpol.R': [// Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'regexp'], [/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'regexp.delimiter',\n          next: '@pop'\n        },\n        '@default': 'regexp'\n      }\n    }], {\n      include: '@regexpContent'\n    }],\n    // Fallback to the generic sigil by default\n    'sigilStart.interpol': [[/~([a-zA-Z])@sigilStartDelimiter/, {\n      token: 'sigil.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.interpol': [[/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'sigil.delimiter',\n          next: '@pop'\n        },\n        '@default': 'sigil'\n      }\n    }], {\n      include: '@sigilContentInterpol'\n    }],\n    'sigilStart.noInterpol': [[/~([a-zA-Z])@sigilStartDelimiter/, {\n      token: 'sigil.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.noInterpol': [// Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'sigil'], [/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'sigil.delimiter',\n          next: '@pop'\n        },\n        '@default': 'sigil'\n      }\n    }], {\n      include: '@sigilContent'\n    }],\n    // Attributes\n    attributes: [// Module @doc* attributes - tokenized as comments\n    [/\\@(module|type)?doc (~[sS])?\"\"\"/, {\n      token: 'comment.block.documentation',\n      next: '@doubleQuotedHeredocDocstring'\n    }], [/\\@(module|type)?doc (~[sS])?\"/, {\n      token: 'comment.block.documentation',\n      next: '@doubleQuotedStringDocstring'\n    }], [/\\@(module|type)?doc false/, 'comment.block.documentation'], // Module attributes\n    [/\\@(@variableName)/, 'variable']],\n    doubleQuotedHeredocDocstring: [[/\"\"\"/, {\n      token: 'comment.block.documentation',\n      next: '@pop'\n    }], {\n      include: '@docstringContent'\n    }],\n    doubleQuotedStringDocstring: [[/\"/, {\n      token: 'comment.block.documentation',\n      next: '@pop'\n    }], {\n      include: '@docstringContent'\n    }],\n    // Operators, punctuation, brackets\n    symbols: [// Code point operator (either with regular character ?a or an escaped one ?\\n)\n    [/\\?(\\\\.|[^\\\\\\s])/, 'number.constant'], // Anonymous function arguments\n    [/&\\d+/, 'operator'], // Bitshift operators (must go before delimiters, so that << >> don't match first)\n    [/<<<|>>>/, 'operator'], // Delimiter pairs\n    [/[()\\[\\]\\{\\}]|<<|>>/, '@brackets'], // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)\n    [/\\.\\.\\./, 'identifier'], // Punctuation => (must go before operators, so it's not tokenized as = then >)\n    [/=>/, 'punctuation'], // Operators\n    [/@operator/, 'operator'], // Punctuation\n    [/[:;,.%]/, 'punctuation']],\n    // Generic helpers\n    stringContentInterpol: [{\n      include: '@interpolation'\n    }, {\n      include: '@escapeChar'\n    }, {\n      include: '@stringContent'\n    }],\n    stringContent: [[/./, 'string']],\n    stringConstantContentInterpol: [{\n      include: '@interpolation'\n    }, {\n      include: '@escapeChar'\n    }, {\n      include: '@stringConstantContent'\n    }],\n    stringConstantContent: [[/./, 'constant']],\n    regexpContentInterpol: [{\n      include: '@interpolation'\n    }, {\n      include: '@escapeChar'\n    }, {\n      include: '@regexpContent'\n    }],\n    regexpContent: [// # may be a regular regexp char, so we use a heuristic\n    // assuming a # surrounded by whitespace is actually a comment.\n    [/(\\s)(#)(\\s.*)$/, ['white', 'comment.punctuation', 'comment']], [/./, 'regexp']],\n    sigilContentInterpol: [{\n      include: '@interpolation'\n    }, {\n      include: '@escapeChar'\n    }, {\n      include: '@sigilContent'\n    }],\n    sigilContent: [[/./, 'sigil']],\n    docstringContent: [[/./, 'comment.block.documentation']],\n    escapeChar: [[/@escape/, 'constant.character.escape']],\n    interpolation: [[/#{/, {\n      token: 'delimiter.bracket.embed',\n      next: '@interpolationContinue'\n    }]],\n    interpolationContinue: [[/}/, {\n      token: 'delimiter.bracket.embed',\n      next: '@pop'\n    }], // Interpolation brackets may contain arbitrary code,\n    // so we simply match against all the root rules,\n    // until we reach interpolation end (the above matches).\n    {\n      include: '@root'\n    }]\n  }\n};"],"names":["conf","comments","lineComment","brackets","surroundingPairs","open","close","autoClosingPairs","notIn","indentationRules","increaseIndentPattern","decreaseIndentPattern","language","defaultToken","tokenPostfix","token","declarationKeywords","operatorKeywords","namespaceKeywords","otherKeywords","constants","nameBuiltin","operator","variableName","atomName","specialAtomName","aliasPart","moduleName","sigilSymmetricDelimiter","sigilStartDelimiter","sigilEndDelimiter","decimal","hex","octal","binary","escape","tokenizer","root","include","whitespace","keywordsShorthand","next","doubleQuotedStringKeyword","singleQuotedStringKeyword","numbers","identifiers","cases","unquote","strings","doubleQuotedHeredoc","singleQuotedHeredoc","doubleQuotedString","singleQuotedString","atoms","doubleQuotedStringAtom","singleQuotedStringAtom","sigils","sigil","switchTo","attributes","doubleQuotedHeredocDocstring","doubleQuotedStringDocstring","symbols","stringContentInterpol","stringContent","stringConstantContentInterpol","stringConstantContent","regexpContentInterpol","regexpContent","sigilContentInterpol","sigilContent","docstringContent","escapeChar","interpolation","interpolationContinue"],"sourceRoot":""}