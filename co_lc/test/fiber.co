# +ir -print
# +eval -print
let child = \n ->
  yield;
  n + 5
in
let child = spawn (child 10) in
let child = resume child in
stat child
| `Pending -> 101
| `Done n -> n

> +ir -print
> child: {
> % Stack relative to frame pointer:
> %   -5  #return
> %   -4  n
> %   -3  @old_pc
> %   -2  @old_fp
> %   -1  @old_sp
> child:
>   sp-add 0
> start1:
>   yield
>   push 5
>   push fp[-4]
>   add
>   store-into fp[-5]
>   ret
> }
> 
> spawn_wrapper: {
> % Stack relative to frame pointer:
> %   -4  #return
> %   -3  @old_pc
> %   -2  @old_fp
> %   -1  @old_sp
> spawn_wrapper:
>   sp-add 0
> start2:
>   sp-add 1
>   push 10
>   push &child
>   call
>   sp-sub 1
>   store-into fp[-4]
>   ret
> }
> 
> @main: {
> % Stack relative to frame pointer:
> %   -4  #return
> %   -3  @old_pc
> %   -2  @old_fp
> %   -1  @old_sp
> %    0  child1.stkdirty
> %    1  child1.stkidx
> %    2  child1.return
> %    3  child1.bit
> %    4  child2.stkdirty
> %    5  child2.stkidx
> %    6  child2.return
> %    7  child2.bit
> %    8  n1
> @main:
>   sp-add 9
> start:
>   push &spawn_wrapper
>   spawn 0 1
>   store-into fp[3]
>   store-into fp[2]
>   store-into fp[1]
>   store-into fp[0]
>   push fp[0]
>   push fp[1]
>   push fp[2]
>   push fp[3]
>   resume 1
>   store-into fp[7]
>   store-into fp[6]
>   store-into fp[5]
>   store-into fp[4]
>   push fp[4]
>   push fp[5]
>   push fp[6]
>   push fp[7]
>   jmpz pending
> done:
>   store-into fp[8]
>   sp-sub 2
>   push fp[8]
>   store-into fp[-4]
>   jmp join
> pending:
>   sp-sub 3
>   push 101
>   store-into fp[-4]
>   jmp join
> join:
>   ret
> }

> +eval -print
> 15